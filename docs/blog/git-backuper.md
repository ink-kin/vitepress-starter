---
title: Используем GIT для резервного копирования
head:
  - - meta
    - name: description
      content: 'git — the stupid content tracker Обратите внимание: не Version control system, не Software configuration management system, а именно Content tracker. GITу наплевать, что хранить'
tags:
- git
categories:
- Innovate
- git
---

## Используем GIT для резервного копирования

Если открыть ман GIT’а, мы увидим, что он начинается со следующей строчки:

git — the stupid content tracker



Обратите внимание: не Version control system, не Software configuration management system, а именно Content tracker. GITу наплевать, что хранить — для него каждый файл это тупо набор байт. Они даже называются — blob‘ы. А раз GITу необязательно работать именно с текстом, почему бы не хранить в нём всё что угодно — фотографии, музыку и прочее барахло? Конечно, посмотреть diff двух фотографий не получится, а вот откатиться к предыдущей версии документа, над которым идёт работа — вполне.

versionsЗнакомая картина? Не смущайтесь, у всех хоть когда-нибудь да был такой бардак в документах. Вроде бы старая версия уже не нужна, но вдруг в новой было удалено что-то важное? Вот и копятся эти бесконечные копии.

Git позволяет забыть об этом, как о страшном сне. Начнём с создания репозитория:

git init --separate-git-dir="/путь/к/диску/на/котором/вы/храните/резервные/копии"

Ключ --separate-git-dir позволяет отделить рабочую копию (которой, собственно, и является папка с документами) от репозитория. (Естественно, репозиторий должен быть на отдельном винчестере — мы же всё-таки занимаемся резервным копированием). В результате вместо папки с именем .git создаётся текстовый файл с тем же именем, в котором содержится путь к репозиторию.

Дальше всё как обычно:

git add --all .
git commit -m "Backup #42"

Времени уйдёт ровно столько, сколько нужно для чтения с диска всех сохраняемых файлов. То есть по времени Git соответствует обычному копированию. Вот только места резервные копии будут занимать ровно столько, сколько во всех версиях было разных файлов.

То есть было у вас 1000 фотографий в папке, скажем, «DCIM/100OLYMP» с именами P1090024.JPG, P1090025.JPG и т.д. весом 5 ГиБ. Вы скопировали их в папку «Я_и_моя_сраная_кошка» и переименовали в «на_фоне_ковра.jpg» и т.д. В результате папка с фотографиями будет занимать 10 ГиБ, а вот её резервная копия, сделанная Git’ом — всё те же 5. Если потом вы измените, скажем, десяток фоток (обрежете, поиграете с уровнями и пр.) и опять сделаете бэкап — объём репозитория увеличится ровно на размер изменённых фотографий.

Таким образом я забэкапил всё более-менее важное, что у меня было. Получилась куча репозиториев гигабайт по 50. Конечно, работается с ними медленнее, чем с нормальным репом с исходниками, но мне-то что? Запустил git add в фоне и работаешь себе дальше.

ADVERTISEMENT
REPORT THIS AD

Ясное дело, я был уверен, что забиваю гвозди микроскопом. Даже Бен Линн в своей «Магии Git» так прямо и написал:

Perhaps a database or backup/archival solution is what is actually being sought, not a version control system.

Я считал свою находку с Git временным решением, до тех пор пока не дойдут руки до изучения нормальных систем резервного копирования. А потом я из любопытства решил посмотреть формат бэкапов свой Jolla:jolla_backupВот тебе раз! Оказывается, создатели Sailfish мыслили в точности так же, как и я! Нужно всего лишь распаковать архив — и можно checkout’ить любое из состояний телефона, как последнее, так и более старые:

jolla-backup-hist

Как говорится, великие умы мыслят одинаково.
